# 第二次作业

1. 证明线性筛使用一个prime数组，不影响程序的正确性

   代码如下：

   ```c
   #include <stdio.h>
   #define MAX_N 10000
   int prime[MAX_N + 5] = {0};
   //int is_prime[MAX_N + 5] = {0};
   
   int main() {
       /*for (int M = 2; M <= MAX_N; M++) {
           if (!is_prime[M]) {
               prime[++prime[0]] = M;
           }
           for (int i = 1, j = prime[i]; i <= prime[0]; i++, j = prime[i]) {
               if (M * j > MAX_N) break;
               is_prime[M * j] = 1;
               if(M % j == 0) break;
           }
       }*/
       for (int i = 2; i <= MAX_N; i++) {
           if (!prime[i]) {
               prime[++prime[0]] = i;
           }
           for (int j = 1; j <= prime[0] && prime[j] * i <= MAX_N; j++) {
               prime[i * prime[j]] = 1;
               if (i % prime[j] == 0) break;
           }
       }
   
       for (int i = 1; i <= prime[0]; i++) {
           printf("%d ",prime[i]);
       }
       printf("\n");
       return 0;
   }
   ```

   证明：在21行到23行代码中，是将能用 i 标记的数都标记了，而i标记的数都是比i大的，所以在17行的循环过程中，第18行可以起到判断这个数是否被标记的作用，而且19行还可以更新prime数组，依次将素数存入prime数组中，并且不会影响21行的标记过程，相应的21行的标记过程也不会影响19行的复制过程，所以一个prime数组就可以完成线性筛。

2. 自行完成欧拉第10题

3. 查阅资料，自学【缓存命中率】的相关知识

   当用户访问一个数据的时候，如果缓存区中存有该数据，则命中；否则未命中，需要再从其他地方读取该数据。

   缓存命中率的大小与缓存的容量及缓存存储策略有关，缓存容量大命中率自然就会高一点，好的存储策略也可以提高缓存命中率。

4. 自行完成欧拉第17题

5. 自行完成欧拉第16题（选做）

   

   

   

   

   作业提交：hug@haizeix.com

   

   