### C++

1. `f()`和`f(void)`的区别：
   - `C`中：`f()`代表参数个数没有限制；`f(void)`代表参数为空。
   - `C++`中：`f()`和`f(void)`均代表参数为空。

2. `C`中的`const`和`C++`中的`const`的区别：

   - `C`中的`const`是一个只读类型的变量，不能直接修改其值，但可通过指针修改，他们共用一个地址空间；

     例如，`C`中下面程序代码输出的结果是`6, 6`。

     ```c
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     printf("%d, %d\n", a, *p)
     ```

   - `C++`中的`const`是真正的常量，用指针引用的时候会再给其分配一个地址空间。

     例如，`C++`中下面程序代码输出的结果是`5, 6`。

     ```c++
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     cout << a << ", " << *p << endl;
     ```

3. `C++`中`const`与`define`的区别：

   - `const`有作用域，`define`的作用域一般为全局。

4. 函数重载与函数指针一起使用的时候，参数个数、参数类型以及返回值类型都要相同。函数指针与函数重载举例：

   ```c++
   int add() {
       return 1;
   }
   
   int add(int a, int b) {
       return a + b;
   }
   
   int (*p1)(int, int);
   int (*p2)();
   p1 = add;
   p2 = add;
   printf("%p, %p\n", p1, p2)
   ```

   补充：重载函数的地址不相同，故上述代码打印出来的`p1`和`p2`的地址不同。

5. `new`和`delete`：

   ```c++
   type *name = new type;           // 申请单个地址
   delete name;
   type *name = new type(value);    // 申请单个地址并赋初值
   delete name;
   type *name = new type[length];   // 申请一片连续的地址空间
   delete []name;
   ```

6. 堆、栈、全局。

   - 堆：（`new`， `malloc`出来的变量）默认值是随机值；
   - 栈：（正常声明的变量）默认值是随机值；
   - 全局：默认值是`0`。

7. 构造函数

   - 自动调用构造函数：

     ```c++
     Test t1;            // 调用无参构造函数
     Test t2(1);         // 调用带一个参数的构造函数
     Test t3 = 1;        // 调用带一个参数的构造函数
     ```

     注：`Test t2()`并不会调用无参构造函数，而会被系统认为是一个函数的声明。

   - 手动调用构造函数：

     ```c++
     Test *t1 = new Test(1);
     Test t2[3] = {Test(), Test(2), Test(3)};
     ```

8. 拷贝构造函数

   注：当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数（浅拷贝）。

   ```c++
   Test(const Test &obj) {    // 默认拷贝构造函数
       a = obj.a;
   }
   
   Test t2 = t1;              // 拷贝（调用拷贝构造函数）
   
   Test t2;
   t2 = t1;                   // 赋值（不会调拷贝构造函数）
   ```

   注：自己实现拷贝构造函数的时候，一定要用深拷贝。

   - 浅拷贝：拷贝之后物理状态相同，对象里面有指针的话会指向同一地址空间。
   - 深拷贝：逻辑状态相同。
