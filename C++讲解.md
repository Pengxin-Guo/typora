### C++

1. `f()`和`f(void)`的区别：
   - `C`中：`f()`代表参数个数没有限制；`f(void)`代表参数为空。
   - `C++`中：`f()`和`f(void)`均代表参数为空。

2. `C`语言中真正的常量只有枚举类型，`const`是只读变量。

3. `C`中的`const`和`C++`中的`const`的区别：

   - `C`中的`const`是一个只读类型的变量，不能直接修改其值，但可通过指针修改，他们共用一个地址空间；

     例如，`C`中下面程序代码输出的结果是`6, 6`。

     ```c
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     printf("%d, %d\n", a, *p)
     ```

   - `C++`中的`const`是真正的常量，用指针引用的时候会再给其分配一个地址空间。

     例如，`C++`中下面程序代码输出的结果是`5, 6`。

     ```c++
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     cout << a << ", " << *p << endl;
     ```

4. `C++`中`const`与宏的区别：

   - 宏没有作用域和变量类型的检查，他只是简单的替换，如果想给其作用域，用`undef`；
   - `const`有作用域和变量类型的检查；

5. `C`语言中函数的参数是不允许有默认值的；`C++`中函数带默认值的时候最好将其写到函数声明中去，函数实现的时候就别写了。

6. 函数重载：

   - 同一作用域；
   - 函数名相同；
   - 参数列表不同（参数类型、参数个数、参数顺序）；

7. 函数重载与函数指针一起使用的时候，参数个数、参数类型以及返回值类型都要相同。函数指针与函数重载举例：

   ```c++
   int add() {
       return 1;
   }
   
   int add(int a, int b) {
       return a + b;
   }
   
   int (*p1)(int, int);
   int (*p2)();
   p1 = add;
   p2 = add;
   printf("%p, %p\n", p1, p2)
   ```

   补充：重载函数的地址不相同，故上述代码打印出来的`p1`和`p2`的地址不同。

8. `new`和`delete`：

   ```c++
   type *name = new type;           // 申请单个地址
   delete name;
   type *name = new type(value);    // 申请单个地址并赋初值
   delete name;
   type *name = new type[length];   // 申请一片连续的地址空间
   delete []name;
   ```

9. 不能返回局部变量的引用；

10. 堆、栈、全局。

   - 堆：（`new`， `malloc`出来的变量）默认值是随机值；
   - 栈：（正常声明的变量）默认值是随机值；
   - 全局：默认值是`0`。

11. 构造函数

   - 自动调用构造函数：

     ```c++
     Test t1;            // 调用无参构造函数
     Test t2(1);         // 调用带一个参数的构造函数
     Test t3 = 1;        // 调用带一个参数的构造函数
     ```

     注：`Test t2()`并不会调用无参构造函数，而会被系统认为是一个函数的声明。

   - 手动调用构造函数：

     ```c++
     Test *t1 = new Test(1);
     Test t2[3] = {Test(), Test(2), Test(3)};
     ```

11. 拷贝构造函数

    注：当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数（浅拷贝）。【简单的值复制】

    ```c++
    Test(const Test &obj) {    // 默认拷贝构造函数
        a = obj.a;
    }
    
    Test t2 = t1;              // 拷贝（调用拷贝构造函数）
    
    Test t2;
    t2 = t1;                   // 赋值（不会调拷贝构造函数）
    ```

    注：涉及到指针、内存相关的操作的时候，一定要自己实现拷贝构造函数，自己实现拷贝构造函数的时候，**一定要用深拷贝**。

    - 浅拷贝：拷贝之后物理状态相同，对象里面有指针的话会指向同一地址空间。
    - 深拷贝：逻辑状态相同。

12. 初始化列表

    以下情况必须使用初始化列表对成员变量初始化：

    - `const`成员属性；
    - 类属性且这个类中只有带参构造函数时；

    两种实现初始化列表的方法：

    ```c++
    class Value {
    private:
        int i;
    public:
        Value(int a) : i(a) {
            cout << "Value :: i = " << i << endl;
        }
    };
    
    class Test {
    private:
        const int i;
        int j;
        Value v1;
        Value v2;
        Value v3;
    public:
        /*
        Test(int a, int b) : i(a), j(b), v1(1), v3(3), v2(2) {
            cout << "i = " << i << endl;
        }*/
        Test(int a, int b);
    };
    
    Test::Test(int a, int b) : i(a), j(b), v1(1), v3(3), v2(2) {
        cout << "i = " << i << endl;
        cout << "j = " << j << endl;
    }
    ```

    注：初始化列表初始化顺序与成员变量声明顺序相同，与初始化列表中的顺序无关；初始化列表优先于函数体执行。

13. 析构函数的作用：对象销毁之前，做一些相关的清理工作，这个函数它会自动调用。

14. 对象的构造顺序与析构顺序

    - 构造顺序：先父母，再朋友，最后自己；

    - 析构顺序：与构造顺序相反；（先构造的后析构）
    - 因为C++标准中没有规定全局对象的构造顺序，故不同编译器实现的就不同，所以尽量不要使用全局对象；

15. `static`静态成员变量的使用：

    ```c++
    class Test {
        private:
        static int cnt;        // 定义
        public:
        Test() {
            cnt += 1;
        }
        ~Test() {
            cnt -= 1;
        }
    }
    
    int Test::cnt = 0;         // 初始化
    ```

    注：在类中定义，在全局初始化。

    特点：

    - 静态成员属性属于整个类；
    - 生命周期和类一样，贯穿于整个程序；
    - 可以通过类名直接访问公有的静态成员变量；
    - 所有对象都共享；

16. 静态成员函数不能访问非静态成员属性；非静态成员函数可以访问静态成员属性。

17. `const`对象、`const`成员变量和`const`方法

    - `const`可以修饰一个对象，用法：`const className name`，只不过这个对象是只读的，里面的属性都是只读变量；

    - 在编译期只读对象的属性的值不能被改变；

    - `const`对象只能调用`const`方法；

      注：`const`方法：`int getI() const {}`

    - `const`成员变量必须得初始化【利用初始化列表】；

    - `const`成员变量是只读变量；

    - `const`方法只能调用`const`方法；

    - `const`方法中不能更改成员变量的值；

    - `const`方法也能与普通成员方法构成重载关系；

18. 返回值优化

    写程序的时候可能出现临时对象、匿名对象，导致程序出现随机值，这时需要返回值优化；`g++`编译器默认帮我们实现了返回值优化功能；

19. 继承：类与类的一种关系

    - 子类继承了父类的所有属性和方法（包括`private`的，只不过子类也不可见而已）；
    - 父子兼容：子类是一种特殊的父类 == > 子类对象也可以当父类对象用；父类对象的指针可以指向子类对象；父类对象的引用可以引用子类对象；
    - 子类调用父类构造函数：
      - 自动调用方式：要求父类构造函数必须是无参构造函数或者是带默认参数的构造函数；
      - 手动调用方式：在子类构造函数初始化列表中调用；

20. 一个对象是一个特殊的结构体，运行时它会退化成结构体

    特点如下：

    - 成员属性是依次排列的；
    - 成员属性之间可能存在内存空隙；
    - 可以通过内存地址直接访问；
    - 访问权限只在编译期有效，运行期无效；

21. 多继承

    - 二义性　　== > 作用域
    - 数据冗余　== > 虚继承
    - 多个虚函数指针

22. 虚继承【`virtual`】：用了虚继承之后，要在最底层的子类构造函数中显式调用最顶层父类的构造函数；

23. 多态：根据实际对象去判断调用的重写函数

    多态的意义：在程序中表现出动态的特性；在子类中重写父类的同名函数时，必须在父类中将其声明成虚函数，否则没有意义；多态是面向对象的基础。

    - 静态联编：程序在编译期间就知道调用哪个函数 == > 函数重载；
    - 动态联编：程序在运行期间才知道调用哪个函数 == > 函数重写；

24. `C++`中多态原理，当有`virtual`时，编译器改变了对象的内存排布：

    - 在类声明对象的时候，编译器会自动生成一个虚函数表；
    - 虚函数表存的是成员函数的地址；
    - 虚函数表是由编译器自动生成和维护的；
    - 被`virtual`声明的虚函数会被放入虚函数表中；
    - 类中存在虚函数时，每个对象会有一个指针指向虚函数表，并且这个指针存在对象的头部；

25. 抽象类

    - 虚函数：被`virtual`修饰的函数；
    - 纯虚函数：只有声明函数原型的成员函数；例：`virtual int add() = 0`；
    - 抽象类：一个含有纯虚函数的类；只能定义类型，不能产生对象；

26. 接口：是一种特殊的抽象类【一组函数原型】：

    - 这个抽象类中没有任何成员变量；
    - 所有成员函数都是公有的纯虚函数；

27. 泛型编程：函数模板；类模板。

28. 函数模板：一种**泛型编程**方式（不考虑具体数据类型的一种编程方式）；

    ```c++
    template <typename T>                // 单类型函数模板
    template <typename T1, typename T2>  // 多类型函数模板
    ```

    对函数模板的编译将会进行两次检查，第一次是对这个模板本身的检查，检查其有无语法错误；传入具体的数据类型后，会生成具体的函数，然后会对这个具体的函数再进行一次检查。

    模板的意义：

    - `C++`中泛型模板的应用方式之一；
    - 函数模板能够根据实参类型进行参数类型自动推导；
    - 函数模板支持显示指定参数类型；
    - 函数模板是`C++`中代码复用的一种方式；

    函数模板使用注意事项：

    - 本身不支持类型隐式转换；
    - 在**自动推导类型**时，必须严格遵守类型匹配，而且不会进行隐式类型转换；
    - **显示指定参数类型**时，能够进行隐式类型转换；

    多类型函数模板的注意事项：

    - 返回值类型无法自动推导，必须明确指出返回值类型；
    - 可以从左到右部分指定参数类型；

    模板参数可以是数值类型参数：

    ```c++
    template <typename T, int N>
    void fun() {
        T a[N];
    }
    int main() {
        fun<double, 10>();
        int a = 10;
        fun<double, a>();  // 错误, 参数类型不能是变量s
    }
    ```

    注：数值类型的参数不能用变量，也不能用浮点类型、类类型；

29. 重载函数的调用顺序

    优先调用普通函数，之后是模板函数，最后是变参函数；

30. 类模板：不用去管数据类型，只是对数据进行操作。

    - 类模板函数声明与实现要写在一个文件里面；

31. 类模板的特化：部分特化（偏特化）；完全特化。

    - 可以有多个类型参数；
    - 特化只是类模板的分开实现；
    - 特化的类模板与初始的类模板使用方式一样，必须显示指定参数的类型；

    注：**函数模板只支持完全特化**。

32. 异常`or` `Bug`

    - `Bug`：程序中不可预期的执行。如：堆申请内存未释放；野指针；排序`0`长度的数组；
    - 异常：可预期的分支执行。如：除数为`0`；数组访问越界；要打开的文件不存在；

33. `try,catch`

    - `try`抛出异常，`catch`捕获异常，是从上向下严格匹配的；
    - `try`后面可以跟多个`catch`；
    - `catch()`块中可以定义具体异常类型；
    - 不同异常类型由不同`catch`去匹配；
    - `catch(...)`是可以处理任意类型异常的，并只能放在最后；
    - 任意一种类型异常只能被捕获一次；

    匹配规则：

    - 自上而下严格匹配异常类型；
    - 匹配时，不进行类型转换；

    异常补充知识（异常是类类型）：

    - 异常也可是自定义类型的；
    - 同样遵循自上而下的严格匹配；
    - 父子兼容依然适用；
    - 一般将匹配子类异常的放在上面；

34. 友元

    - 在类中某个函数前用`friend`修饰；
    - 友元函数不是类的一部分（一般都是全局函数）；
    - 友元函数不受类的访问权限限制；
    - 友元函数能访问类中一切属性；

35. 操作符重载

    - 通过函数重载去扩展系统操作符功能；
    - 操作符重载是以函数方式进行的；
    - 本质：还是一种函数；

    注：有些操作符只能重载为成员函数；操作符重载不能改变原有操作符的优先级；不能改变原运算符的操作个数；不能改变原运算符的原生语义；

36. 智能指针

    特性：

    - 能自动回收堆空间；
    - 一片内存空间只能有一个指针指向（避免多次释放）；
    - 杜绝指针运算；

    重载`*`和`->`的注意事项：

    - 只能重载成成员函数；
    - 重载函数不能有参数；
    - 一个类中只能定义一个这个重载函数；

37. 强制类型转换

    - `static_cast`：强制将一种数据类型转化成另一种数据类型；
    - `const_cast`：用于去除指向常数对象的指针或引用的常量性；
    - `reinterpret_cast`：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整形转化为指针或引用类型；
    - `dynamic_cast`：其他三种都是编译时完成的，这个是运行时处理的，运行时要进行类型检查；使用这个进行类类型转换时，基类中要有虚函数，否则编译不通过；不能用于内置的基本数据类型的转换；
