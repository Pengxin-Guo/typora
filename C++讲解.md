### C++

1. `f()`和`f(void)`的区别：
   - `C`中：`f()`代表参数个数没有限制；`f(void)`代表参数为空。
   - `C++`中：`f()`和`f(void)`均代表参数为空。

2. `C`语言中真正的常量只有枚举类型，`const`是只读变量。

3. `C`中的`const`和`C++`中的`const`的区别：

   - `C`中的`const`是一个只读类型的变量，不能直接修改其值，但可通过指针修改，他们共用一个地址空间；

     例如，`C`中下面程序代码输出的结果是`6, 6`。

     ```c
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     printf("%d, %d\n", a, *p)
     ```

   - `C++`中的`const`是真正的常量，用指针引用的时候会再给其分配一个地址空间。

     例如，`C++`中下面程序代码输出的结果是`5, 6`。

     ```c++
     const int a = 5;
     int *p = (int *)&a;
     *p = 6;
     cout << a << ", " << *p << endl;
     ```

4. `C++`中`const`与宏的区别：

   - 宏没有作用域和变量类型的检查，他只是简单的替换，如果想给其作用域，用`undef`；
   - `const`有作用域和变量类型的检查；

5. `C`语言中函数的参数是不允许有默认值的；`C++`中函数带默认值的时候最好将其写到函数声明中去，函数实现的时候就别写了。

6. 函数重载：

   - 同一作用域；
   - 函数名相同；
   - 参数列表不同（参数类型、参数个数、参数顺序）；

7. 函数重载与函数指针一起使用的时候，参数个数、参数类型以及返回值类型都要相同。函数指针与函数重载举例：

   ```c++
   int add() {
       return 1;
   }
   
   int add(int a, int b) {
       return a + b;
   }
   
   int (*p1)(int, int);
   int (*p2)();
   p1 = add;
   p2 = add;
   printf("%p, %p\n", p1, p2)
   ```

   补充：重载函数的地址不相同，故上述代码打印出来的`p1`和`p2`的地址不同。

8. `new`和`delete`：

   ```c++
   type *name = new type;           // 申请单个地址
   delete name;
   type *name = new type(value);    // 申请单个地址并赋初值
   delete name;
   type *name = new type[length];   // 申请一片连续的地址空间
   delete []name;
   ```

9. 不能返回局部变量的引用；

10. 堆、栈、全局。

   - 堆：（`new`， `malloc`出来的变量）默认值是随机值；
   - 栈：（正常声明的变量）默认值是随机值；
   - 全局：默认值是`0`。

11. 构造函数

   - 自动调用构造函数：

     ```c++
     Test t1;            // 调用无参构造函数
     Test t2(1);         // 调用带一个参数的构造函数
     Test t3 = 1;        // 调用带一个参数的构造函数
     ```

     注：`Test t2()`并不会调用无参构造函数，而会被系统认为是一个函数的声明。

   - 手动调用构造函数：

     ```c++
     Test *t1 = new Test(1);
     Test t2[3] = {Test(), Test(2), Test(3)};
     ```

11. 拷贝构造函数

    注：当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数（浅拷贝）。【简单的值复制】

    ```c++
    Test(const Test &obj) {    // 默认拷贝构造函数
        a = obj.a;
    }
    
    Test t2 = t1;              // 拷贝（调用拷贝构造函数）
    
    Test t2;
    t2 = t1;                   // 赋值（不会调拷贝构造函数）
    ```

    注：涉及到指针、内存相关的操作的时候，一定要自己实现拷贝构造函数，自己实现拷贝构造函数的时候，**一定要用深拷贝**。

    - 浅拷贝：拷贝之后物理状态相同，对象里面有指针的话会指向同一地址空间。
    - 深拷贝：逻辑状态相同。

12. 初始化列表

    以下情况必须使用初始化列表对成员变量初始化：

    - `const`成员属性；
    - 类属性且这个类中只有带参构造函数时；

    两种实现初始化列表的方法：

    ```c++
    class Value {
    private:
        int i;
    public:
        Value(int a) : i(a) {
            cout << "Value :: i = " << i << endl;
        }
    };
    
    class Test {
    private:
        const int i;
        int j;
        Value v1;
        Value v2;
        Value v3;
    public:
        /*
        Test(int a, int b) : i(a), j(b), v1(1), v3(3), v2(2) {
            cout << "i = " << i << endl;
        }*/
        Test(int a, int b);
    };
    
    Test::Test(int a, int b) : i(a), j(b), v1(1), v3(3), v2(2) {
        cout << "i = " << i << endl;
        cout << "j = " << j << endl;
    }
    ```

    注：初始化列表初始化顺序与成员变量声明顺序相同，与初始化列表中的顺序无关；初始化列表优先于函数体执行。

13. 对象的构造顺序与析构顺序

    - 构造顺序：先父母，再朋友，最后自己；

    - 析构顺序：与构造顺序相反；（先构造的后析构）
    - 因为C++标准中没有规定全局对象的构造顺序，故不同编译器实现的就不同，所以尽量不要使用全局对象；

14. `const`对象、`const`成员变量和`const`方法

    - `const`可以修饰一个对象，只不过这个对象是只读的；

    - `const`对象只能调用`const`方法；

      注：`const`方法：`int getI() const {}`

    - `const`方法只能调用`const`方法；

    - `const`成员函数中不能更改成员变量的值；

    - `const`方法也能与普通成员方法构成重载关系；

15. 继承

    - 子类继承了父类的所有属性和方法（包括`private`的，只不过子类也不可见而已）；
    - 子类是一种特殊的父类 == > 子类对象也可以当父类对象用；父类对象的指针可以指向子类对象；父类对象的引用可以引用子类对象；
    - 子类调用父类构造函数：
      - 自动调用方式：要求父类构造函数必须是无参构造函数或者是带默认参数的构造函数；
      - 手动调用方式：在子类构造函数初始化列表中调用；

16. 一个对象是一个特殊的结构体，运行时它会退化成结构体

    - 成员属性是依次排列的；
    - 成员属性之间可能存在空隙；
    - 可以通过内存地址直接访问；
    - 访问权限只在编译期有效，运行期无效；

17. 多继承

    - 二义性　　== > 作用域
    - 数据冗余　== > 虚继承
    - 多个虚函数指针

18. 多态

    - 静态联编：程序在编译期间就知道调用哪个函数 == > 函数重载；
    - 动态联编：程序在运行期间才知道调用哪个函数 == > 函数重写；

19. 函数模板：一种泛型编程方式（不考虑具体数据类型的一种编程方式）；

    函数模板的特点：

    - 本身不支持类型隐式转换；
    - 在自动推倒类型时，必须严格遵守类型匹配，而不会进行隐式类型转换；
    - 显示指定时，能够进行隐式类型转换；

    多类型函数模板的特点：

    - 返回值类型必须明确指出；
    - 可以从左到右部分指定类型；
