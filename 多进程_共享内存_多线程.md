### 多进程　共享内存　多线程

1. **进程**是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

2. **共享内存**指 在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存。任何一个缓存的数据被更新后，由于其他处理器也可能要存取，共享内存就需要立即更新，否则不同的处理器可能用到不同的数据。共享内存是 Unix下的多进程之间的通信方法 ,这种方法通常用于一个程序的多进程间通信，实际上多个程序间也可以通过共享内存来传递信息。

3. **线程**，有时被称为轻量进程，是程序执行流的最小单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。

4. `Linux`中**共享内存**的相关函数:

   - `shmget`函数：

     ```c
     int shmget(key_ t key, size_t size, int shmflg);//该函数用来创建共享内存
     ```

     第一个参数，与信号量的semget函数一样，程序需要提供一个参数`key`（非0整数），它有效地为共享内存段命名，`shmget`函数成功时返回一个与`key`相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回`-1`。

     第二个参数，`size`以字节为单位指定需要共享的内存容量。

     第三个参数，`shmflg`是权限标志，它的作用与`open`函数的`mode`参数一样，如果要想在`key`标识的共享内存不存在时，创建它的话，可以与`IPC_CREAT`做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，`0644`,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。

   - `shmat`函数：

     ```c
     void *shmat(int shm_id, const void *shm_addr, int shmflg);
     //第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间
     ```

     第一个参数，`shm_id`是由`shmget`函数返回的共享内存标识。 

     第二个参数，`shm_addr`指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。 

     第三个参数，`shm_flg`是一组标志位，通常为`0`。

   - `shmdt`函数：

     ```c
     int shmdt(const void *shmaddr);
     //该函数用于将共享内存从当前进程中分离。
     //注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用
     ```

     参数shmaddr是shmat函数返回的地址指针，调用成功时返回0，失败时返回-1。

   - `scmctl`函数：

     ```c
     int shmctl(int shm_id, int command, struct shmid_ds *buf);
     //与信号量的semctl函数一样，用来控制共享内存
     ```

     第一个参数，`shm_id`是`shmget`函数返回的共享内存标识符。 
     第二个参数，`command`是要采取的操作，它可以取下面的三个值 ： 
     `IPC_STAT`：把`shmid_ds`结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖`shmid_ds`的值；
     `IPC_SET`：如果进程有足够的权限，就把共享内存的当前关联值设置为`shmid_ds`结构中给出的值 ；
     `IPC_RMID`：删除共享内存段。

     第三个参数，`buf`是一个结构指针，它指向共享内存模式和访问权限的结构。